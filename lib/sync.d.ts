import { IComparer, ITuple, IEqualityComparer, IConstructor, RecOrdMap } from "./shared";
export interface IEnumerable<TSource> extends Iterable<TSource> {
    aggregate(func: (x: TSource, y: TSource) => TSource): TSource;
    aggregate<TAccumulate>(seed: TAccumulate, func: (x: TAccumulate, y: TSource) => TAccumulate): TAccumulate;
    aggregate<TAccumulate, TResult>(seed: TAccumulate, func: (x: TAccumulate, y: TSource) => TAccumulate, resultSelector: (x: TAccumulate) => TResult): TResult;
    all(predicate: (x: TSource) => boolean): boolean;
    any(predicate?: (x: TSource) => boolean): boolean;
    average(this: IEnumerable<number>): number;
    average(selector: (x: TSource) => number): number;
    concat(second: IEnumerable<TSource>): IEnumerable<TSource>;
    contains(value: TSource, comparer?: IEqualityComparer<TSource>): boolean;
    count(predicate?: (x: TSource) => boolean): number;
    distinct(comparer?: IEqualityComparer<TSource>): IEnumerable<TSource>;
    elementAt(index: number): TSource;
    elementAtOrDefault(index: number): TSource | null;
    except(second: Iterable<TSource>, comparer?: IEqualityComparer<TSource>): IEnumerable<TSource>;
    first(predicate?: (x: TSource) => boolean): TSource;
    firstOrDefault(predicate?: (x: TSource) => boolean): TSource | null;
    each(action: (x: TSource) => void): IEnumerable<TSource>;
    groupBy(keySelector: (x: TSource) => number): IEnumerable<IGrouping<number, TSource>>;
    groupBy(keySelector: (x: TSource) => string): IEnumerable<IGrouping<string, TSource>>;
    groupBy<TKey>(keySelector: (x: TSource) => TKey, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, TSource>>;
    groupByWithSel<TElement>(keySelector: ((x: TSource) => number), elementSelector: (x: TSource) => TElement): IEnumerable<IGrouping<number, TElement>>;
    groupByWithSel<TElement>(keySelector: ((x: TSource) => string), elementSelector: (x: TSource) => TElement): IEnumerable<IGrouping<string, TElement>>;
    groupByWithSel<TKey, TElement>(keySelector: ((x: TSource) => TKey), elementSelector: (x: TSource) => TElement, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, TElement>>;
    intersect(second: IEnumerable<TSource>, comparer?: IEqualityComparer<TSource>): IEnumerable<TSource>;
    joinByKey<TInner, TKey, TResult>(inner: IEnumerable<TInner>, outerKeySelector: (x: TSource) => TKey, innerKeySelector: (x: TInner) => TKey, resultSelector: (x: TSource, y: TInner) => TResult, comparer?: IEqualityComparer<TKey>): IEnumerable<TResult>;
    last(predicate?: (x: TSource) => boolean): TSource;
    lastOrDefault(predicate?: (x: TSource) => boolean): TSource | null;
    max(this: IEnumerable<number>): number;
    max(selector: (x: TSource) => number): number;
    min(this: IEnumerable<number>): number | never;
    min(selector: (x: TSource) => number): number | never;
    ofType(type: "object"): IEnumerable<Object>;
    ofType(type: "function"): IEnumerable<Function>;
    ofType(type: "symbol"): IEnumerable<Symbol>;
    ofType(type: "boolean"): IEnumerable<boolean>;
    ofType(type: "number"): IEnumerable<number>;
    ofType(type: "string"): IEnumerable<string>;
    ofType<TResult>(type: IConstructor<TResult>): IEnumerable<TResult>;
    orderBy(predicate: (x: TSource) => number | string): IOrderedEnumerable<TSource>;
    orderBy(predicate: (x: TSource) => number, comparer: IComparer<number>): IOrderedEnumerable<TSource>;
    orderBy(predicate: (x: TSource) => string, comparer: IComparer<string>): IOrderedEnumerable<TSource>;
    orderByDescending(predicate: (x: TSource) => number | string): IOrderedEnumerable<TSource>;
    orderByDescending(predicate: (x: TSource) => number, comparer: IComparer<number>): IOrderedEnumerable<TSource>;
    orderByDescending(predicate: (x: TSource) => string, comparer: IComparer<string>): IOrderedEnumerable<TSource>;
    reverse(): IEnumerable<TSource>;
    select<OUT>(selector: (x: TSource) => OUT): IEnumerable<OUT>;
    select<TKey extends keyof TSource>(key: TKey): IEnumerable<TSource[TKey]>;
    selectMany<OUT>(selector: (x: TSource) => Iterable<OUT>): IEnumerable<OUT>;
    selectMany<TBindedSource extends {
        [key: string]: Iterable<TOut>;
    }, TOut>(this: IEnumerable<TBindedSource>, selector: keyof TBindedSource): IEnumerable<TOut>;
    sequenceEquals(second: IEnumerable<TSource>, comparer?: IEqualityComparer<TSource>): boolean;
    single(predicate?: (x: TSource) => boolean): TSource;
    singleOrDefault(predicate?: (x: TSource) => boolean): TSource | null;
    skip(count: number): IEnumerable<TSource>;
    skipWhile(predicate: (x: TSource, index: number) => boolean): IEnumerable<TSource>;
    sum(this: IEnumerable<number>): number;
    sum(selector: (x: TSource) => number): number;
    take(amount: number): IEnumerable<TSource>;
    takeWhile(predicate: (x: TSource, index: number) => boolean): IEnumerable<TSource>;
    toArray(): TSource[];
    toMap<TKey>(selector: (x: TSource) => TKey): Map<TKey, TSource[]>;
    toSet(): Set<TSource>;
    union(second: Iterable<TSource>, comparer?: IEqualityComparer<TSource>): IEnumerable<TSource>;
    where(predicate: (x: TSource, index: number) => boolean): IEnumerable<TSource>;
    zip<TSecond>(second: Iterable<TSecond>): IEnumerable<ITuple<TSource, TSecond>>;
    zip<TSecond, TResult>(second: Iterable<TSecond>, resultSelector: (x: TSource, y: TSecond) => TResult): IEnumerable<TResult>;
    [Symbol.iterator](): IterableIterator<TSource>;
}
export interface IOrderedEnumerable<TSource> extends IEnumerable<TSource> {
    thenBy: {
        (keySelector: (x: TSource) => string | number): IOrderedEnumerable<TSource>;
        (keySelector: (x: TSource) => number, comparer: IComparer<number>): IOrderedEnumerable<TSource>;
        (keySelector: (x: TSource) => string, comparer: IComparer<string>): IOrderedEnumerable<TSource>;
    };
    thenByDescending: {
        (keySelector: (x: TSource) => string | number): IOrderedEnumerable<TSource>;
        (keySelector: (x: TSource) => number, comparer: IComparer<number>): IOrderedEnumerable<TSource>;
        (keySelector: (x: TSource) => string, comparer: IComparer<string>): IOrderedEnumerable<TSource>;
    };
    getMap: {
        (): RecOrdMap<TSource>;
    };
}
export interface IGrouping<TKey, TElement> extends IEnumerable<TElement> {
    readonly key: TKey;
}
export declare class Enumerable {
    static aggregate<TSource>(source: Iterable<TSource>, func: (x: TSource, y: TSource) => TSource): TSource;
    static aggregate<TSource, TAccumulate>(source: Iterable<TSource>, seed: TAccumulate, func: (x: TAccumulate, y: TSource) => TAccumulate): TAccumulate;
    static aggregate<TSource, TAccumulate, TResult>(source: Iterable<TSource>, seed: TAccumulate, func: (x: TAccumulate, y: TSource) => TAccumulate, resultSelector: (x: TAccumulate) => TResult): TResult;
    private static aggregate_1<TSource>(source, func);
    private static aggregate_2<TSource, TAccumulate>(source, seed, func);
    private static aggregate_3<TSource, TAccumulate, TResult>(source, seed, func, resultSelector);
    static all<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): boolean;
    static any<TSource>(source: Iterable<TSource>, predicate?: (x: TSource) => boolean): boolean;
    private static any_1<TSource>(source);
    private static any_2<TSource>(source, predicate);
    static average(source: Iterable<number>): number;
    static average<TSource>(source: Iterable<TSource>, selector: (x: TSource) => number): number;
    private static average_1(source);
    private static average_2<TSource>(source, func);
    static concat<TSource>(first: Iterable<TSource>, second: IEnumerable<TSource>): IEnumerable<TSource>;
    static contains<TSource>(source: Iterable<TSource>, value: TSource, comparer?: IEqualityComparer<TSource>): boolean;
    static count<TSource>(source: Iterable<TSource>): number;
    static count<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): number;
    private static count_1<T>(source);
    private static count_2<T>(source, predicate);
    static distinct<TSource>(source: Iterable<TSource>, comparer?: IEqualityComparer<TSource>): IEnumerable<TSource>;
    static each<TSource>(source: Iterable<TSource>, action: (x: TSource) => void): IEnumerable<TSource>;
    static elementAt<TSource>(source: Iterable<TSource>, index: number): TSource;
    static elementAtOrDefault<TSource>(source: Iterable<TSource>, index: number): TSource | null;
    static enumerateObject<TInput>(source: TInput): IEnumerable<ITuple<keyof TInput, TInput[keyof TInput]>>;
    static except<TSource>(first: Iterable<TSource>, second: Iterable<TSource>, comparer?: IEqualityComparer<TSource>): IEnumerable<TSource>;
    static first<TSource>(source: Iterable<TSource>): TSource;
    static first<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): TSource;
    private static first_1<T>(source);
    private static first_2<T>(source, predicate);
    static firstOrDefault<T>(source: Iterable<T>): T | null;
    static firstOrDefault<T>(source: Iterable<T>, predicate: (x: T) => boolean): T | null;
    private static firstOrDefault_1<T>(source);
    private static firstOrDefault_2<T>(source, predicate);
    static flatten<TSource>(source: Iterable<TSource | Iterable<TSource>>): IEnumerable<TSource>;
    static flatten<TSource>(source: Iterable<TSource | Iterable<TSource>>, shallow: false): IEnumerable<TSource>;
    static flatten<TSource>(source: Iterable<TSource | Iterable<TSource>>, shallow: true): IEnumerable<TSource | Iterable<TSource>>;
    static from<TSource>(source: TSource[]): IEnumerable<TSource>;
    static from<TSource>(source: IterableIterator<TSource>): IEnumerable<TSource>;
    static groupBy<TSource>(source: Iterable<TSource>, keySelector: (x: TSource) => number): IEnumerable<IGrouping<number, TSource>>;
    static groupBy<TSource>(source: Iterable<TSource>, keySelector: (x: TSource) => string): IEnumerable<IGrouping<string, TSource>>;
    static groupBy<TSource, TKey>(source: Iterable<TSource>, keySelector: (x: TSource) => TKey, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, TSource>>;
    private static groupBy_0_Simple<TSource>(source, keySelector);
    private static groupBy_0<TSource, TKey>(source, keySelector, comparer);
    static groupByWithSel<TSource, TElement>(source: Iterable<TSource>, keySelector: ((x: TSource) => number), elementSelector: (x: TSource) => TElement): IEnumerable<IGrouping<number, TElement>>;
    static groupByWithSel<TSource, TElement>(source: Iterable<TSource>, keySelector: ((x: TSource) => string), elementSelector: (x: TSource) => TElement): IEnumerable<IGrouping<string, TElement>>;
    static groupByWithSel<TSource, TKey, TElement>(source: Iterable<TSource>, keySelector: ((x: TSource) => TKey), elementSelector: (x: TSource) => TElement, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, TElement>>;
    private static groupBy_1_Simple<TSource, TElement>(source, keySelector, elementSelector);
    private static groupBy_1<TSource, TKey, TElement>(source, keySelector, elementSelector, comparer);
    static groupByWithResult<TSource, TResult>(source: Iterable<TSource>, keySelector: (x: TSource) => string, resultSelector: (x: string, values: IEnumerable<TSource>) => TResult): IEnumerable<TResult>;
    static groupByWithResult<TSource, TResult>(source: Iterable<TSource>, keySelector: (x: TSource) => string, resultSelector: (x: string, values: IEnumerable<TSource>) => TResult, comparer: IEqualityComparer<string>): IEnumerable<TResult>;
    static groupByWithResult<TSource, TResult>(source: Iterable<TSource>, keySelector: (x: TSource) => number, resultSelector: (x: number, values: IEnumerable<TSource>) => TResult): IEnumerable<TResult>;
    static groupByWithResult<TSource, TResult>(source: Iterable<TSource>, keySelector: (x: TSource) => number, resultSelector: (x: number, values: IEnumerable<TSource>) => TResult, comparer: IEqualityComparer<number>): IEnumerable<TResult>;
    static groupByWithResult<TSource, TKey, TResult>(source: Iterable<TSource>, keySelector: (x: TSource) => TKey, resultSelector: (x: TKey, values: IEnumerable<TSource>) => TResult): IEnumerable<TResult>;
    static groupByWithResult<TSource, TKey, TResult>(source: Iterable<TSource>, keySelector: (x: TSource) => number, resultSelector: (x: TKey, values: IEnumerable<TSource>) => TResult, comparer: IEqualityComparer<TKey>): IEnumerable<TResult>;
    private static groupBy_2_Simple<TSource, TResult>(source, keySelector, resultSelector);
    private static groupBy_2<TSource, TKey, TResult>(source, keySelector, resultSelector, comparer?);
    static GroupByWithResultAndSelector<TSource, TKey, TElement, TResult>(source: Iterable<TSource>, keySelector: ((x: TSource) => TKey) | ((x: TSource) => string) | ((x: TSource) => number), elementSelector: (x: TSource) => TElement, resultSelector: ((key: TKey, values: IEnumerable<TElement>) => TResult) | ((key: string | number, values: IEnumerable<TElement>) => TResult), comparer?: IEqualityComparer<TKey>): IEnumerable<TResult>;
    private static groupBy_3<TSource, TKey, TElement, TResult>(source, keySelector, elementSelector, resultSelector, comparer?);
    private static groupBy_3_Simple<TSource, TElement, TResult>(source, keySelector, elementSelector, resultSelector);
    static join<TOuter, TInner, TKey, TResult>(outer: Iterable<TOuter>, inner: Iterable<TInner>, outerKeySelector: (x: TOuter) => TKey, innerKeySelector: (x: TInner) => TKey, resultSelector: (x: TOuter, y: TInner) => TResult): IEnumerable<TResult>;
    static join<TOuter, TInner, TKey, TResult>(outer: Iterable<TOuter>, inner: Iterable<TInner>, outerKeySelector: (x: TOuter) => TKey, innerKeySelector: (x: TInner) => TKey, resultSelector: (x: TOuter, y: TInner) => TResult, comparer: IEqualityComparer<TKey>): IEnumerable<TResult>;
    static intersect<TSource>(first: IEnumerable<TSource>, second: Iterable<TSource>, comparer?: IEqualityComparer<TSource>): IEnumerable<TSource>;
    static partition<TSource>(source: Iterable<TSource>, predicate: (x: TSource) => boolean): TSource[][];
    static select<TSource, TResult>(source: Iterable<TSource>, selector: (x: TSource) => TResult): IEnumerable<TResult>;
    static select<TSource, TKey extends keyof TSource>(source: Iterable<TSource>, key: TKey): IEnumerable<TSource[TKey]>;
    private static select_1<TSource, TResult>(source, selector);
    private static select_2<TSource, TKey>(source, key);
    static selectMany<TSource, TResult>(source: Iterable<TSource>, selector: (x: TSource) => Iterable<TResult>): IEnumerable<TResult>;
    static selectMany<TSource extends {
        [key: string]: Iterable<TResult>;
    }, TResult>(source: Iterable<TSource>, selector: keyof TSource): IEnumerable<TResult>;
    private static selectMany_1<TSource, TResult>(source, selector);
    static selectMany_2<TSource extends {
        [key: string]: Iterable<TResult>;
    }, TResult>(source: Iterable<TSource>, selector: keyof TSource): BasicEnumerable<TResult>;
    static single<TSource>(source: Iterable<TSource>, predicate?: (x: TSource) => boolean): TSource;
    private static single_1<TSource>(source);
    private static single_2<TSource>(source, predicate);
    static singleOrDefault<TSource>(source: Iterable<TSource>, predicate?: (x: TSource) => boolean): TSource | null;
    private static singleOrDefault_1<TSource>(source);
    private static singleOrDefault_2<TSource>(source, predicate);
    static skipWhile<TSource>(source: Iterable<TSource>, predicate: (x: TSource, index: number) => boolean): IEnumerable<TSource>;
    private static skipWhile_1<TSource>(source, predicate);
    private static skipWhile_2<TSource>(source, predicate);
    static skip<TSource>(source: Iterable<TSource>, count: number): IEnumerable<TSource>;
    static empty<TSource>(): IEnumerable<TSource>;
    static last<TSource>(source: Iterable<TSource>, predicate?: (x: TSource) => boolean): TSource;
    private static last_1<TSource>(source);
    private static last_2<TSource>(source, predicate);
    static lastOrDefault<TSource>(source: Iterable<TSource>, predicate?: (x: TSource) => boolean): TSource | null;
    private static lastOrDefault_1<TSource>(source);
    private static lastOrDefault_2<TSource>(source, predicate);
    static max(source: Iterable<number>): number;
    static max<TSource>(source: Iterable<TSource>, selector: (x: TSource) => number): number;
    private static max_1(source);
    private static max_2<TSource>(source, selector);
    static min(source: Iterable<number>): number;
    static min<TSource>(source: Iterable<TSource>, selector: (x: TSource) => number): number;
    private static min_1(source);
    private static min_2<TSource>(source, selector);
    static ofType<TSource, TResult>(source: Iterable<TSource>, type: IConstructor<TResult> | string): IEnumerable<TResult>;
    private static orderByInner<TSource>(source, keySelector);
    static orderBy<TSource>(source: IEnumerable<TSource>, keySelector: (x: TSource) => string): IOrderedEnumerable<TSource>;
    static orderBy<TSource>(source: IEnumerable<TSource>, keySelector: (x: TSource) => string, comparer: IComparer<string>): IOrderedEnumerable<TSource>;
    static orderBy<TSource>(source: IEnumerable<TSource>, keySelector: (x: TSource) => number): IOrderedEnumerable<TSource>;
    static orderBy<TSource>(source: IEnumerable<TSource>, keySelector: (x: TSource) => number, comparer: IComparer<number>): IOrderedEnumerable<TSource>;
    static orderByDescending<TSource>(source: IEnumerable<TSource>, keySelector: (x: TSource) => string): IOrderedEnumerable<TSource>;
    static orderByDescending<TSource>(source: IEnumerable<TSource>, keySelector: (x: TSource) => string, comparer: IComparer<string>): IOrderedEnumerable<TSource>;
    static orderByDescending<TSource>(source: IEnumerable<TSource>, keySelector: (x: TSource) => number): IOrderedEnumerable<TSource>;
    static orderByDescending<TSource>(source: IEnumerable<TSource>, keySelector: (x: TSource) => number, comparer: IComparer<number>): IOrderedEnumerable<TSource>;
    static range(start: number, count: number): IEnumerable<number>;
    static repeat<T>(element: T, count: number): IEnumerable<T>;
    static reverse<TSource>(source: Iterable<TSource>): IEnumerable<TSource>;
    static sequenceEquals<TSource>(first: Iterable<TSource>, second: Iterable<TSource>, comparer?: IEqualityComparer<TSource>): boolean;
    static sum(source: Iterable<number>): number;
    static sum<TSource>(source: Iterable<TSource>, selector: (x: TSource) => number): number;
    private static sum_1(source);
    private static sum_2<TSource>(source, selector);
    static take<T>(source: Iterable<T>, amount: number): IEnumerable<T>;
    static takeWhile<T>(source: Iterable<T>, predicate: (x: T, index: number) => boolean): IEnumerable<T>;
    private static takeWhile_1<T>(source, predicate);
    private static takeWhile_2<T>(source, predicate);
    static thenBy<TSource>(source: IOrderedEnumerable<TSource>, keySelector: (x: TSource) => string): IOrderedEnumerable<TSource>;
    static thenBy<TSource>(source: IOrderedEnumerable<TSource>, keySelector: (x: TSource) => string, comparer: IComparer<string>): IOrderedEnumerable<TSource>;
    static thenBy<TSource>(source: IOrderedEnumerable<TSource>, keySelector: (x: TSource) => number): IOrderedEnumerable<TSource>;
    static thenBy<TSource>(source: IOrderedEnumerable<TSource>, keySelector: (x: TSource) => number, comparer: IComparer<number>): IOrderedEnumerable<TSource>;
    static thenByDescending<TSource>(source: IOrderedEnumerable<TSource>, keySelector: (x: TSource) => string): IOrderedEnumerable<TSource>;
    static thenByDescending<TSource>(source: IOrderedEnumerable<TSource>, keySelector: (x: TSource) => string, comparer: IComparer<string>): IOrderedEnumerable<TSource>;
    static thenByDescending<TSource>(source: IOrderedEnumerable<TSource>, keySelector: (x: TSource) => number): IOrderedEnumerable<TSource>;
    static thenByDescending<TSource>(source: IOrderedEnumerable<TSource>, keySelector: (x: TSource) => number, comparer: IComparer<number>): IOrderedEnumerable<TSource>;
    static toArray<TSource>(source: Iterable<TSource>): TSource[];
    static toMap<K, V>(source: Iterable<V>, selector: (x: V) => K): Map<K, V[]>;
    static toObject<TSource>(source: Iterable<TSource>, selector: (x: TSource) => string): {
        [key: string]: TSource;
    };
    static toSet<TSource>(source: Iterable<TSource>): Set<TSource>;
    static union<TSource>(first: Iterable<TSource>, second: Iterable<TSource>, comparer?: IEqualityComparer<TSource>): IEnumerable<TSource>;
    private static union_1<TSource>(first, second);
    private static union_2<TSource>(first, second, comparer);
    static where<T>(source: Iterable<T>, predicate: (x: T, index: number) => boolean): IEnumerable<T>;
    private static where_1<T>(source, predicate);
    private static where_2<T>(source, predicate);
    static zip<T, Y>(source: Iterable<T>, second: Iterable<Y>): IEnumerable<ITuple<T, Y>>;
    static zip<T, Y, OUT>(source: Iterable<T>, second: Iterable<Y>, resultSelector: (x: T, y: Y) => OUT): IEnumerable<OUT>;
    private static zip_1<T, Y>(source, second);
    private static zip_2<T, Y, OUT>(source, second, resultSelector);
    private constructor();
}
export declare abstract class BaseEnumerable<T> implements IEnumerable<T> {
    aggregate(func: (x: T, y: T) => T): T;
    aggregate<TAccumulate>(seed: TAccumulate, func: (x: TAccumulate, y: T) => TAccumulate): TAccumulate;
    aggregate<TAccumulate, TResult>(seed: TAccumulate, func: (x: TAccumulate, y: T) => TAccumulate, resultSelector: (x: TAccumulate) => TResult): T;
    all(predicate: (x: T) => boolean): boolean;
    any(predicate?: (x: T) => boolean): boolean;
    average(this: IEnumerable<number>): number;
    average(selector: (x: T) => number): number;
    concat(second: IEnumerable<T>): IEnumerable<T>;
    contains(value: T): boolean;
    contains(value: T, comparer: IEqualityComparer<T>): boolean;
    count(predicate?: (x: T) => boolean): number;
    distinct(comparer?: IEqualityComparer<T>): IEnumerable<T>;
    elementAt(index: number): T;
    elementAtOrDefault(index: number): T | null;
    except(second: Iterable<T>, comparer?: IEqualityComparer<T>): IEnumerable<T>;
    first(predicate?: (x: T) => boolean): T;
    firstOrDefault(predicate?: (x: T) => boolean): T | null;
    each(action: (x: T) => void): IEnumerable<T>;
    groupBy(keySelector: (x: T) => number): IEnumerable<IGrouping<number, T>>;
    groupBy(keySelector: (x: T) => string): IEnumerable<IGrouping<string, T>>;
    groupBy<TKey>(keySelector: (x: T) => TKey, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, T>>;
    groupByWithSel<TElement>(keySelector: ((x: T) => number), elementSelector: (x: T) => TElement): IEnumerable<IGrouping<number, TElement>>;
    groupByWithSel<TElement>(keySelector: ((x: T) => string), elementSelector: (x: T) => TElement): IEnumerable<IGrouping<string, TElement>>;
    groupByWithSel<TKey, TElement>(keySelector: ((x: T) => TKey), elementSelector: (x: T) => TElement, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, TElement>>;
    intersect(second: IEnumerable<T>): IEnumerable<T>;
    intersect(second: IEnumerable<T>, comparer: IEqualityComparer<T>): IEnumerable<T>;
    joinByKey<TInner, TKey, TResult>(inner: IEnumerable<TInner>, outerKeySelector: (x: T) => TKey, innerKeySelector: (x: TInner) => TKey, resultSelector: (x: T, y: TInner) => TResult, comparer?: IEqualityComparer<TKey>): IEnumerable<TResult>;
    last(predicate?: (x: T) => boolean): T;
    lastOrDefault(predicate?: (x: T) => boolean): T | null;
    max(this: IEnumerable<number>): number | never;
    max(selector: (x: T) => number): number | never;
    min(this: IEnumerable<number>): number | never;
    min(selector: (x: T) => number): number | never;
    ofType(type: "object"): IEnumerable<Object>;
    ofType(type: "function"): IEnumerable<Function>;
    ofType(type: "symbol"): IEnumerable<Symbol>;
    ofType(type: "boolean"): IEnumerable<boolean>;
    ofType(type: "number"): IEnumerable<number>;
    ofType(type: "string"): IEnumerable<string>;
    ofType<TResult>(type: IConstructor<TResult>): IEnumerable<TResult>;
    orderBy(predicate: (x: T) => number | string): IOrderedEnumerable<T>;
    orderBy(predicate: (x: T) => number, comparer: IComparer<number>): IOrderedEnumerable<T>;
    orderBy(predicate: (x: T) => string, comparer: IComparer<string>): IOrderedEnumerable<T>;
    orderByDescending(predicate: (x: T) => number | string): IOrderedEnumerable<T>;
    orderByDescending(predicate: (x: T) => number, comparer: IComparer<number>): IOrderedEnumerable<T>;
    orderByDescending(predicate: (x: T) => string, comparer: IComparer<string>): IOrderedEnumerable<T>;
    reverse(): IEnumerable<T>;
    select<OUT>(selector: (x: T) => OUT): IEnumerable<OUT>;
    select<TKey extends keyof T>(this: IEnumerable<{
        [key: string]: Iterable<T[TKey]>;
    }>, selector: TKey): IEnumerable<T[TKey]>;
    selectMany<TBindedSource extends {
        [key: string]: Iterable<TOut>;
    }, TOut>(this: IEnumerable<TBindedSource>, selector: keyof TBindedSource): IEnumerable<TOut>;
    selectMany<OUT>(selector: (x: T) => Iterable<OUT>): IEnumerable<OUT>;
    sequenceEquals(second: IEnumerable<T>, comparer?: IEqualityComparer<T>): boolean;
    single(predicate?: (x: T) => boolean): T;
    singleOrDefault(predicate?: (x: T) => boolean): T | null;
    skip(count: number): IEnumerable<T>;
    skipWhile(predicate: (x: T, index: number) => boolean): IEnumerable<T>;
    sum(this: IEnumerable<number>): number;
    sum(selector: (x: T) => number): number;
    take(amount: number): IEnumerable<T>;
    takeWhile(predicate: (x: T, index: number) => boolean): IEnumerable<T>;
    toArray(): T[];
    toMap<TKey>(selector: (x: T) => TKey): Map<TKey, T[]>;
    toSet(): Set<T>;
    union(second: Iterable<T>, comparer?: IEqualityComparer<T>): IEnumerable<T>;
    where(predicate: (x: T, index: number) => boolean): IEnumerable<T>;
    zip<TSecond>(second: Iterable<TSecond>): IEnumerable<ITuple<T, TSecond>>;
    zip<TSecond, TResult>(second: Iterable<TSecond>, resultSelector: (x: T, y: TSecond) => TResult): IEnumerable<TResult>;
    abstract [Symbol.iterator](): IterableIterator<T>;
}
export declare class BasicEnumerable<TSource> extends BaseEnumerable<TSource> {
    private readonly iterator;
    constructor(iterator: () => IterableIterator<TSource>);
    [Symbol.iterator](): IterableIterator<TSource>;
}
export declare class OrderedEnumerable<T> extends BasicEnumerable<T> implements IOrderedEnumerable<T> {
    private readonly map;
    private static unrollAndSort<T>(map, comparer?);
    private static generate<T>(mapFunc, comparer?);
    constructor(map: () => RecOrdMap<T>, comparer?: IComparer<number | string>);
    getMap(): RecOrdMap<T>;
    thenBy(keySelector: (x: T) => string | number): IOrderedEnumerable<T>;
    thenBy(keySelector: (x: T) => number, comparer: IComparer<number>): IOrderedEnumerable<T>;
    thenBy(keySelector: (x: T) => string, comparer: IComparer<string>): IOrderedEnumerable<T>;
    thenByDescending(keySelector: (x: T) => string | number): IOrderedEnumerable<T>;
    thenByDescending(keySelector: (x: T) => number, comparer: IComparer<number>): IOrderedEnumerable<T>;
    thenByDescending(keySelector: (x: T) => string, comparer: IComparer<string>): IOrderedEnumerable<T>;
}
export declare class OrderedEnumerableDescending<T> extends BasicEnumerable<T> implements IOrderedEnumerable<T> {
    private readonly map;
    private static unrollAndSort<T>(map, comparer?);
    private static generate<T>(mapFunc, comparer?);
    constructor(map: () => RecOrdMap<T>, comparer?: IComparer<number | string>);
    getMap(): RecOrdMap<T>;
    thenBy(keySelector: (x: T) => string | number): IOrderedEnumerable<T>;
    thenBy(keySelector: (x: T) => number, comparer: IComparer<number>): IOrderedEnumerable<T>;
    thenBy(keySelector: (x: T) => string, comparer: IComparer<string>): IOrderedEnumerable<T>;
    thenByDescending(keySelector: (x: T) => string | number): IOrderedEnumerable<T>;
    thenByDescending(keySelector: (x: T) => number, comparer: IComparer<number>): IOrderedEnumerable<T>;
    thenByDescending(keySelector: (x: T) => string, comparer: IComparer<string>): IOrderedEnumerable<T>;
}
export declare class ArrayEnumerable<T> extends Array<T> implements IEnumerable<T> {
    aggregate(func: (x: T, y: T) => T): T;
    aggregate<TAccumulate>(seed: TAccumulate, func: (x: TAccumulate, y: T) => TAccumulate): TAccumulate;
    aggregate<TAccumulate, TResult>(seed: TAccumulate, func: (x: TAccumulate, y: T) => TAccumulate, resultSelector: (x: TAccumulate) => TResult): T;
    all(predicate: (x: T) => boolean): boolean;
    any(predicate?: (x: T) => boolean): boolean;
    average(this: IEnumerable<number>): number;
    average(selector: (x: T) => number): number;
    concat(items: IEnumerable<T>): IEnumerable<T>;
    concat(...items: Array<ReadonlyArray<T>>): ArrayEnumerable<T>;
    concat(...items: Array<T | ReadonlyArray<T>>): ArrayEnumerable<T>;
    contains(value: T, comparer?: IEqualityComparer<T>): boolean;
    count(): number;
    count(predicate: (x: T) => boolean): number;
    distinct(comparer?: IEqualityComparer<T>): IEnumerable<T>;
    elementAt(index: number): T;
    elementAtOrDefault(index: number): T | null;
    except(second: Iterable<T>, comparer?: IEqualityComparer<T>): IEnumerable<T>;
    first(predicate?: (x: T) => boolean): T;
    firstOrDefault(): T | null;
    firstOrDefault(predicate: (x: T) => boolean): T | null;
    each(action: (x: T) => void): IEnumerable<T>;
    groupBy(keySelector: (x: T) => number): IEnumerable<IGrouping<number, T>>;
    groupBy(keySelector: (x: T) => string): IEnumerable<IGrouping<string, T>>;
    groupBy<TKey>(keySelector: (x: T) => TKey, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, T>>;
    groupByWithSel<TElement>(keySelector: ((x: T) => number), elementSelector: (x: T) => TElement): IEnumerable<IGrouping<number, TElement>>;
    groupByWithSel<TElement>(keySelector: ((x: T) => string), elementSelector: (x: T) => TElement): IEnumerable<IGrouping<string, TElement>>;
    groupByWithSel<TKey, TElement>(keySelector: ((x: T) => TKey), elementSelector: (x: T) => TElement, comparer: IEqualityComparer<TKey>): IEnumerable<IGrouping<TKey, TElement>>;
    intersect(second: IEnumerable<T>, comparer?: IEqualityComparer<T>): IEnumerable<T>;
    joinByKey<TInner, TKey, TResult>(inner: IEnumerable<TInner>, outerKeySelector: (x: T) => TKey, innerKeySelector: (x: TInner) => TKey, resultSelector: (x: T, y: TInner) => TResult, comparer?: IEqualityComparer<TKey>): IEnumerable<TResult>;
    last(predicate?: (x: T) => boolean): T;
    lastOrDefault(predicate?: (x: T) => boolean): T | null;
    max(this: IEnumerable<number>): number | never;
    max(selector: (x: T) => number): number | never;
    min(this: IEnumerable<number>): number | never;
    min(selector: (x: T) => number): number | never;
    ofType(type: "object"): IEnumerable<Object>;
    ofType(type: "function"): IEnumerable<Function>;
    ofType(type: "symbol"): IEnumerable<Symbol>;
    ofType(type: "boolean"): IEnumerable<boolean>;
    ofType(type: "number"): IEnumerable<number>;
    ofType(type: "string"): IEnumerable<string>;
    ofType<TResult>(type: IConstructor<TResult>): IEnumerable<TResult>;
    orderBy(predicate: (x: T) => number | string): IOrderedEnumerable<T>;
    orderBy(predicate: (x: T) => number, comparer: IComparer<number>): IOrderedEnumerable<T>;
    orderBy(predicate: (x: T) => string, comparer: IComparer<string>): IOrderedEnumerable<T>;
    orderByDescending(predicate: (x: T) => number | string): IOrderedEnumerable<T>;
    orderByDescending(predicate: (x: T) => number, comparer: IComparer<number>): IOrderedEnumerable<T>;
    orderByDescending(predicate: (x: T) => string, comparer: IComparer<string>): IOrderedEnumerable<T>;
    reverse(): ArrayEnumerable<T>;
    select<OUT>(selector: (x: T) => OUT): IEnumerable<OUT>;
    select<TKey extends keyof T>(this: IEnumerable<{
        [key: string]: T[TKey];
    }>, selector: TKey): IEnumerable<T[TKey]>;
    selectMany<TBindedSource extends {
        [key: string]: Iterable<TOut>;
    }, TOut>(this: IEnumerable<TBindedSource>, selector: keyof TBindedSource): IEnumerable<TOut>;
    selectMany<OUT>(selector: (x: T) => Iterable<OUT>): IEnumerable<OUT>;
    sequenceEquals(second: IEnumerable<T>, comparer?: IEqualityComparer<T>): boolean;
    single(predicate?: (x: T) => boolean): T;
    singleOrDefault(predicate?: (x: T) => boolean): T | null;
    skip(count: number): IEnumerable<T>;
    skipWhile(predicate: (x: T, index: number) => boolean): IEnumerable<T>;
    sum(this: IEnumerable<number>): number;
    sum(selector: (x: T) => number): number;
    take(amount: number): IEnumerable<T>;
    takeWhile(predicate: (x: T, index: number) => boolean): IEnumerable<T>;
    toArray(): T[];
    toMap<TKey>(selector: (x: T) => TKey): Map<TKey, T[]>;
    toSet(): Set<T>;
    union(second: Iterable<T>, comparer?: IEqualityComparer<T>): IEnumerable<T>;
    where(predicate: (x: T, index: number) => boolean): IEnumerable<T>;
    zip<TSecond>(second: Iterable<TSecond>): IEnumerable<ITuple<T, TSecond>>;
    zip<TSecond, TResult>(second: Iterable<TSecond>, resultSelector: (x: T, y: TSecond) => TResult): IEnumerable<TResult>;
}
export declare class Grouping<TKey, TElement> extends ArrayEnumerable<TElement> {
    readonly key: TKey;
    constructor(key: TKey, startingItem: TElement);
}
